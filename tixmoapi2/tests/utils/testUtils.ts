import prisma from '../../src/config/prisma';
import request from 'supertest';
export { prisma };

export async function safeCleanupUsers(filter = 'test') {
  const testUsers = await prisma.user.findMany({
    where: { email: { contains: filter } },
    select: { id: true },
  });

  const userIds = testUsers.map((u) => u.id);
  if (!userIds.length) return;

  // Delete dependent records in order to avoid FK constraint errors
  const deleteIfExists = async (fn: () => Promise<any>) => {
    try {
      await fn();
    } catch (e) {
      // swallow - cleanup best-effort
    }
  };

  await deleteIfExists(() => prisma.ticket.deleteMany({ where: { userId: { in: userIds } } }));
  await deleteIfExists(() => prisma.order.deleteMany({ where: { userId: { in: userIds } } }));

  // Add other dependent deletes here if needed (sessions, refresh tokens, etc.)

  await deleteIfExists(() => prisma.user.deleteMany({ where: { id: { in: userIds } } }));
}

export async function registerUser(
  app: any,
  overrides: Partial<{
    email: string;
    password: string;
    firstName: string;
    lastName: string;
    role: string;
  }> = {}
) {
  const defaultUser = {
    email: `test-${Date.now()}@example.com`,
    password: 'SecurePass123!',
    firstName: 'Test',
    lastName: 'User',
  };

  const userPayload = { ...defaultUser, ...overrides };
  const res = await request(app).post('/api/v1/auth/register').send(userPayload);
  if (!res.body || !res.body.data) {
    throw new Error(`Failed to register user: ${JSON.stringify(res.body)}`);
  }
  return res.body.data; // { user, accessToken, refreshToken }
}

// New helpers: createOrganization, createVenue, createEvent, createOrder
export async function createOrganization(
  app: any,
  authToken: string,
  payload: Partial<{ name: string; slug: string; type: string; contactEmail: string }> = {}
) {
  const body = {
    name: payload.name ?? `Org ${Date.now()}`,
    slug: payload.slug ?? `org-${Date.now()}`,
    type: payload.type ?? 'PROMOTER',
    contactEmail: payload.contactEmail ?? 'org@example.com',
  };

  const res = await request(app)
    .post('/api/v1/organizations')
    .set('Authorization', `Bearer ${authToken}`)
    .send(body);

  if (!res.body || !res.body.data)
    throw new Error(`Failed to create organization: ${JSON.stringify(res.body)}`);
  return res.body.data; // organization object
}

export async function createVenue(
  app: any,
  authToken: string,
  payload: Partial<{ organizationId: string; name: string; address: any; capacity: number }> = {}
) {
  const body = {
    organizationId: payload.organizationId,
    name: payload.name ?? `Venue ${Date.now()}`,
    address: payload.address ?? {
      street: '1 Test St',
      city: 'Test City',
      state: 'TS',
      country: 'USA',
      postalCode: '00000',
    },
    capacity: payload.capacity ?? 100,
  };

  const res = await request(app)
    .post('/api/v1/venues')
    .set('Authorization', `Bearer ${authToken}`)
    .send(body);

  if (!res.body || !res.body.data)
    throw new Error(`Failed to create venue: ${JSON.stringify(res.body)}`);
  return res.body.data;
}

export async function createEvent(
  app: any,
  authToken: string,
  payload: Partial<{
    organizationId: string;
    venueId: string;
    title: string;
    description: string;
    startDateTime: string;
    endDateTime: string;
    status: string;
  }> = {}
) {
  const now = Date.now();
  const body = {
    organizationId: payload.organizationId,
    venueId: payload.venueId,
    title: payload.title ?? `Event ${now}`,
    description: payload.description ?? 'Generated by testUtils',
    startDateTime: payload.startDateTime ?? new Date(now + 24 * 60 * 60 * 1000).toISOString(),
    endDateTime: payload.endDateTime ?? new Date(now + 26 * 60 * 60 * 1000).toISOString(),
    status: payload.status ?? 'DRAFT',
  };

  const res = await request(app)
    .post('/api/v1/events')
    .set('Authorization', `Bearer ${authToken}`)
    .send(body);

  if (!res.body || !res.body.data)
    throw new Error(`Failed to create event: ${JSON.stringify(res.body)}`);
  return res.body.data;
}

export async function createTicketType(
  app: any,
  authToken: string,
  payload: Partial<{
    eventId: string;
    name: string;
    price: number;
    quantity: number;
    maxPerOrder: number;
  }> = {}
) {
  const body = {
    eventId: payload.eventId,
    name: payload.name ?? 'General Admission',
    price: payload.price ?? 10.0,
    quantity: payload.quantity ?? 10,
    maxPerOrder: payload.maxPerOrder ?? 5,
  };

  const res = await request(app)
    .post('/api/v1/ticket-types')
    .set('Authorization', `Bearer ${authToken}`)
    .send(body);

  if (!res.body || !res.body.data)
    throw new Error(`Failed to create ticket type: ${JSON.stringify(res.body)}`);
  return res.body.data;
}

export async function createOrder(
  app: any,
  authToken: string,
  payload: Partial<{ items: Array<{ ticketTypeId: string; quantity: number }> }> = {}
) {
  const body = {
    items: payload.items ?? [],
  };

  const res = await request(app)
    .post('/api/v1/orders')
    .set('Authorization', `Bearer ${authToken}`)
    .send(body);

  if (!res.body || !res.body.data)
    throw new Error(`Failed to create order: ${JSON.stringify(res.body)}`);
  return res.body.data; // order object
}

// Cleanup helper to remove test data in the correct order
export async function cleanupTestData() {
  // Order of deletion matters because of foreign keys
  // 1. Child tables (ScanLog, Scanner, Notification, etc.)
  try {
    await prisma.scanLog.deleteMany();
  } catch (e) {}
  try {
    await prisma.scanner.deleteMany();
  } catch (e) {}
  try {
    await prisma.notification.deleteMany();
  } catch (e) {}
  try {
    await prisma.notificationPreference.deleteMany();
  } catch (e) {}

  // 2. Transactional data (Ticket, Order)
  try {
    await prisma.ticket.deleteMany();
  } catch (e) {}
  try {
    await prisma.order.deleteMany();
  } catch (e) {}

  // 3. Event related
  try {
    await prisma.ticketType.deleteMany();
  } catch (e) {}
  try {
    await prisma.event.deleteMany();
  } catch (e) {}

  // 4. Organization related
  try {
    await prisma.venue.deleteMany();
  } catch (e) {}
  try {
    await prisma.promoCode.deleteMany();
  } catch (e) {}

  // 5. Core entities (User, Organization)
  try {
    await prisma.user.deleteMany();
  } catch (e) {}
  try {
    await prisma.organization.deleteMany();
  } catch (e) {}
}
